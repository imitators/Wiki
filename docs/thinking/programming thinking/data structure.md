# 数据结构

## 二叉查找树

二叉查找树 (有序二叉查找树) 左节点小于根节点，右节点大于根节点。

特点：二叉查找比顺序查找更快。

缺点：在极端情况下会退化成线性链。

## AVL 树

平衡二叉树是能旋转调整的二叉树，且必须完全平衡的二叉树，弥补了二叉查找树的缺陷。

### 特点

- 所有节点左右子树**高度差**不大于 1。
- 适合用于插入删除次数比较少，但**查找多**的情况。
- 因为旋转耗时问题，所以实际的应用不多。更多的地方是用追求局部而不是非常严格整体平衡的红黑树。

缺点：**旋转非常耗时**，入不敷出

### 使用场景

Windows NT 内核中广泛存在

## 2-3 树

2-3 树有两种节点，分别称为 2-节点(普通节点) 和 3-节点(扩充节点)。

```
 ---     -----
 |3|     |3 8|
 ---     -----
 / \     / | \
2   5   2  5  9
```

3-节点使得查找更加扁平化，树从瘦长变为矮胖，更加方便查找。经过进一步演化，3-节点就发展成了红黑树的核心概念：颜色。

如果把红黑树中的红节点写在父节点的左侧，横向的链接被称为**红链接**，红链接只能是左链接。

> 只能是左链接？那么怎么解释部分红黑树的右子节点为红，左子节点为黑呢？

```
// 3-节点与红黑树
                     8b
  3 -r- 8           /  \
 / \     \    =>   3r   9
2   5     9       / \
                 2   5

```

## 红黑树

一种二叉查找树，每个节点增加一个存储位表示节点的颜色（红/黑）。红黑树总是通过旋转和变色达到自平衡，称为**黑色完美平衡**。

定义：

- 根节点、叶子节点 (NIL) 为黑
- 每个红色结点的两个子结点一定都是黑色
- 任意一结点到其每个叶子结点的路径都包含数量相同的黑结点
  - 如果一个结点存在黑子结点，那么该结点肯定有两个子结点

### 特点

- 弱平衡二叉树。相较于 AVL 树旋转更少
- 红黑树的生长是自底向上的，普通二叉查找树的生长是自顶向上的

### 插入节点

插入节点一定为**红色**，更小限度的影响整棵树的结构。

下图为插入节点的叫法**约定**：
```
        PP (祖父节点)
      /       \
    P (父节点)  S (叔叔节点)
  /
I (插入节点)
```

插入过程的**伪代码**如下所示（如遇到伪代码中未提到情景，直接插入节点即可）：

```
if (P 节点为黑色) 直接插入
if (P 节点为红色)
    if (S 节点存在并为红色) {
        S 节点、P 节点变黑
        PP 节点变红
        PP 节点设置为当前插入节点   // 循环上述过程，直到某个插入节点能直接插入为止
    } else {
        if (P 节点和 I 节点方向不一致) 根据 P 节点旋转 
        根据 PP 节点旋转
    }
```

e.g. 插入节点 Br (b:black / r:red):

```
           Ub
          /   \                 Pb
       Pr      Yb             /     \
      /  \                  kr       Ur
    Kb   Rb         =>     / \      /  \
   / \                    Db  Mb   Rb  Yb
  Dr Mr                  /
 /                      Br
Br
```

### 删除节点

下图为删除节点的叫法约定(g:gray,代表与删除无关)：

```
    Pg(替代节点的父节点)
    /         \
Rb(替代节点)   Sb(替代节点的兄弟节点)
             / \
           SLg SRg(兄弟节点的右子节点)
```

\* R 是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。

删除节点的伪代码如下所示：

```
# 删除伪代码
if (只有一个子节点) 代替删除节点
if (有两个子节点) {
    用后继节点代替子节点
    后继节点作为删除节点 // 循环上述过程，直到删除某个叶子节点为止
}
```

> 后继节点：所有节点在x轴投影后，排序在右边第一个的节点。也可以解释为右子节点的最左边节点。

当删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！

替代节点颜色改变逻辑的伪代码如下所示：

```
if (R 节点为红色) 颜色变为删除节点的颜色
if (R 节点在左)
    if (S 结点是红) {
        S 变黑色
        P 变红色
        根据 P 节点左旋
    }
    else (S 节点为黑色) {
        if (SR 节点为红色) {
            S 变 P 的颜色
            P, SR 变黑色
            根据 P 节点左旋
        }
        elseif (SL 节点为红色) {
            S 变红色
            SL 变黑色
            根据 S 节点右旋
        }
        else (SL, SR 节点为黑色) {
            S 变红色
            P 作为新替换节点    //  重复删除节点，直到遇到其他情况为止
        }
    }
else (R 节点在右) ...
```

### 使用场景

C++ STL 中的 Mep 和 Set

Linux 进程调度 Completely Fair Scheduler 用红黑树管理进程控制块，进程的虚拟内存区域存储于红黑树中

Nginx 中管理 Timer，因为红黑树有序，可以很快得到距离当前最小的计时器

Java 中 TreeMap 的实现

## B 树

B 树也称 B- 树,它是一颗多路平衡查找树。B 树的 **阶数-1** 所得的值即为孩子节点的最大数量和存储的键值对数量。

B 树记录键值对，key 记录索引，data 记录数据，根据 key 的大小决定数据的存储位置。

### 插入数据

某个节点插入 key 导致超过阶数时，节点保留中间的 key，其余 key 分裂：

```
# 三阶 B 树的某节点

2 5 8

//插入 9
2 5 8 9

// 分裂
  5
 / \
2  8 9
```

这样的插入可能导致某个节点只有一半得以利用

### 使用场景

**MongoDB**

聚合型数据库 MongoDB 使用 B 树，因为它们都存储键值对，此时查询的时间复杂度为 O(log n)。

因为 B 树只要获得索引就能访问值，所以 MongoDB 的查询速度比 MySQL 快。

## B+ 树

B+ 树分为索引节点 (内部节点) 和叶子节点，数据只存储在叶子节点上，索引节点只保存索引。

### 特点

- 所有查询必须访问叶子节点。

- 所有叶子节点层数相同。

### 使用场景

**MySQL**

在 MySQL 数据库中作为索引结构，此时 B+ 树中的 key 就表示键，而 data 表示了这个键对应的条目在硬盘上的逻辑地址。

B+ 树能**降低树的高度**(正常为 3，最多不过 4~5)，且**增大数据间隔**，加快查询。

相比于 B 树，B+ 树因为**只需要传输索引**，从而能减少搜索非叶子节点带来的随机I/O，提升了性能。

## 参考资料

[红黑树](https://www.jianshu.com/p/e136ec79235c)